---
title: "Aeternum Loader: Blockchain C2"
classes: wide
header:
  teaser: /assets/images/block/logo.png
ribbon: black
description: "Decrypting and analysing"
categories:
  - Threat Research
tags:
  - Threat Research
toc: true
---

# Aeternum C2 BotNet Loader

In the CtrlAltIntel blog on [ErrTraffic](https://ctrlaltintel.com/threat%20research/ErrTraffic/) we observed advertisements on the panel for "Aeternum C2 BotNet Loader", which was a Blockchain-based C2 panel that uses Polygon smart contracts for its command database. 

This was really interesting to us, and we can see why a threat actor might choose to do this. It comes with some advantages:

* The blockchain is not getting seized by the feds 
* You don't **need** public facing infrastructure that could be tracked

You can run the "server-side" panel locally on a VM, hook up a Polygon wallet, and boom - you can start issuing commands to victims - but at a very small cost of MATIC crypto.    

## Getting the Panel

We mentioned that you don't **need** to configure the C2 server panel to be public facing, and actually, it's a very bad idea to do this. The C2 panel is implemented as a `Next.js` web application, which we thankfully found one exposed on `hXXp://23.94.145[.]192:3000/`:

[![1](/assets/images/block/1.png)](/assets/images/block/1.png){: .full}  

After I found this (initially on Censys <3), we checked the source-code to discover the Polygon smart-contract & C2 source-code was exposed public-facing as JavaScript:

[![1](/assets/images/block/2.png)](/assets/images/block/2.png){: .full}  

This REALLY helped understand how the C2 protocol worked, as at this point in time we didn't have a build, and the build itself was hard (for me) to reverse. 

We do think it's cool how the C2 over Blockchain worked, so we want to take the time to break down the surrounding concepts. 

# Command, Control & Crypto (C3)

Looking at the JavaScript source it was clear C2 commands were sent to victims via a Polygon "smart contract". Think of a smart contract as a tiny program that lives forever on the internet, hosted by nodbody and everyone at once. It's stored across a decentralised network of thousands of computers (the Polygon blockchain network). Once deployed, it cannot be deleted or shut down. The program will exist forever at a specific address like `0x7A3B...9F3d`. 

The panel will also allow operators to deploy smart contracts to the Polygon blockchain. These smart contracts contain a function which is called by the malware, via the Polygon RPC, that will return the encrypted command that is decrypted and ran on victim machines. 

## Unlocking the panel

When you first view the panel, you'll be asked for a Polygon private key and told "Your key will be encrypted with AES-256-GCM". 

[![1](/assets/images/block/3.png)](/assets/images/block/3.png){: .full}  

We can validate this is the case, although it is just encrypted and stored with the browsers local storage. At no point does the private key leave the browser!

```js
static async encryptPrivateKey(e, a) {              
    try {
        let t = new TextEncoder().encode(e),
            s = new Uint8Array(16),
            r = localStorage.getItem(this.SALT_KEY + "_" + a);
        r ? s = new Uint8Array(JSON.parse(r)) : (crypto.getRandomValues(s), localStorage.setItem(this.SALT_KEY + "_" + a, JSON.stringify(Array.from(s))));
        let c = navigator.userAgent + navigator.language + screen.colorDepth,  // "Unique" user identifier
            l = await this.deriveKey(a + c, s),                                // AES key derived using the above "Unique" user identifier 
            n = new Uint8Array(12);
        crypto.getRandomValues(n);
        let o = await crypto.subtle.encrypt({
                name: "AES-GCM",
                iv: n
            }, l, t),
            i = {
                iv: Array.from(n),
                data: Array.from(new Uint8Array(o))
            };
        localStorage.setItem(this.STORAGE_KEY + "_" + a, JSON.stringify(i))   // Stored locally 
//[...REDACTED...]
```

This `encryptPrivateKey()` function is later called after the user provides their private key, and the Ethers.js library is used to create a new wallet, derive public addresses and check whether the provided keys were valid. 

```js
let tg = async () => {
    if (!em) return p.oR.error("Enter key");  // User input, em = private key
    ex(!0);
    try {
        eY.setEncryptionKey(em);         
        let e = new i.FR(en),               // RPC provider, en = https://polygon-rpc.com (or some other)
            a = new x.u(em, e),            // New wallet created using Ethers.js x.u = Wallet() 
            t = await a.getAddress();      // Derive public address from private key 

        await R.encryptPrivateKey(em, t), M(t), U(!0), await tm(t);  // Encrypt private key 
        let s = (await e.getNetwork()).chainId.toString(16);          // Attempt to use private key to connect 
        P("0x".concat(s)), ef(""), ed(!1), p.oR.success("Connected securely")
    } catch (e) {
        console.error("Connection error:", e), p.oR.error("Invalid key")
    } finally {
        ex(!1)
    }
}
```

If successful, you unlock the panel where you can see the features and gain further insight than just reading the source:

<center>
<video width="1080" height="720" controls="controls">
<source src="/assets/images/block/4.mp4" type="video/mp4">
</video>
</center>

## Smart Contract Analysis

We mentioned earlier that smart contracts are programs that live on the internet. Like all programs, smart contracts are also written in programming langauges. [Solidity](https://www.soliditylang.org/) is a programming language used for developing smart contracts that run on Etheremum. 

Within the JavaScript we saw Solidity compiled bytecode for the smart contract to run on Ethereum Virtual Machine (EVM), which has been uploaded to [our Github](https://github.com/ctrlaltint3l/intelligence/blob/main/Aeternum%20Loader/Smartcontract_Bytecode): 

[![1](/assets/images/block/6.png)](/assets/images/block/6.png){: .full}  

To create a smart contract, the function `u.P()` maps to `ethers.ContractFactory()`. This takes in an ABI, the bytecode and a signer (derived from user submitted private key) to create a ContractFactory object stored as the variable `s`, which is used to deploy this contract using `s.deploy()`.   

As bytecode is not readable, an Application Binary Interface (ABI) is used to expose the low-level smart contract's functions and make them accessible from a high-level programming language like JavaScript. We can find this hardcoded within the source exposing the functionality of smart contract:

[![1](/assets/images/block/5.png)](/assets/images/block/5.png){: .full}  

1. Constructor - defines a required intilization string, `initialDomain`. This is actually an encrypted C2 command 
2. Event - `DomainUpdated`, the contract logs every change to the stored string (encrypted C2 command)
3. Read-only function - `admin()`, the contract has a single privileged address which is publicly readable
4. Read-only function - `getDomain()`, the contract stores one string value which is publicly readable (encrypted C2 command)
5. State-changing function - `updateDomain()`, allows operator to replace stored string (encrypted C2 command)

### Commands

The C2 commands decrypted have 2 main flags, `all` or `hwid`. If the flag command is `all`, Aeternum loader will proceed running the command regardless. If `hwid`, it'll only run if the provided `hwid` value matches a unique host ID generated by taking the MD5 hash of the `C:`-drive serial number. 

* `all` - run on all endpoints
* `hwid` - run on specific endpoint

All C2 commands will contain a URL which will host the payload Aeterum Loader will execute or make a request too. There are options for command-line arguments, establishing persistence and making "ping" checks via HTTP requests. 

* `hwid:fca8bdd1134497619285f4f9aba60817:url:<URL>` - Execute payload on URL on specific host

* `all:url:<URL>` - Execute payload on URL

* `all:args:<ARGS>:url:<URL>` - Execute payload on URL

* `all:savestartupname:<NAME>:url:<URL>` - Execute payload on URL + establish persistence

* `all:savestartupname:<NAME>:args:<ARGS>:url:<URL>` - Execute payload on URL w. command-line arguments + establish persistence

* `all:ping:url:<URL>` - Make call-back HTTP request to get IPs

Aeternum Loader will decrypt and parse these C2 commands, initially checking for `all` or `hwid` flags. The file extension of the file within the URL is used to decide what "path" to take within the malware execution pattern. Aeternum Loader will reflectively load all DLLs within memory, with file extensions being written to disk before being ran.

#### Decryption

The C2 commands (e.g. `all:ping:url:<URL>`) are stored on the Blockchain encrypted . From the panel source, we can see that they are stored AES-GCM encrypted, with a PBKDF2 key derived from the contract address:

```js
static async deriveKey(e, a) {
let t = new TextEncoder().encode(e),
    s = await crypto.subtle.importKey("raw", t, "PBKDF2", !1, ["deriveKey"]);
return crypto.subtle.deriveKey({
    name: "PBKDF2",
    salt: a.buffer,
    iterations: 1e5,
    hash: "SHA-256"
}, s, {
    name: "AES-GCM",
    length: 256
}, !1, ["encrypt", "decrypt"])
}  
```

The format of encrypted C2 commands are as follows:

```
AES key = PBKDF2( 100,000 iterations + salt/password = lowercase(contract_address) )

hex(base64(IV):base64(AES encrypted data))  
```

This means, from the contract address alone, it's possible to completely decrypt all commands that have been sent to that particular C2 channel. 

# Blockchain Analysis

In the [second blog](), we reverse a build of Aeternum Loader - directly from `LenAI` themselves, eventually extracting the contract address `0x4d70C3393C5d9EC325Edf8b3f289cFA9777e64B0`. We can use Polygon scan to view the 13 transacations surrounding this smart contract:

[![1](/assets/images/block/41.png)](/assets/images/block/41.png){: .full}  

We can see each transaction corresponds to a "Update Domain" event, which are triggered when the `updateDomain()` function is called. We can see all of these were associated with the contracts creator, `0xcaf2c54e400437da717cf215181b170f65187abf`. This is the Polygon address used by `LenAI`. Looking on the "events" tab we can see a historical log of all C2 commands for this specific smart contract:

[![1](/assets/images/block/42.png)](/assets/images/block/42.png){: .full}  

Each of these are AES-GCM encrypted with a key that is derived from the contract address. We can decode each of these commands to plaintext using this [decryption algorithm](https://github.com/ctrlaltint3l/intelligence/blob/main/Aeternum%20Loader/aeternum_c2_command_decrypt.py):

[![1](/assets/images/block/45.png)](/assets/images/block/45.png){: .full}  

## Pivoting 

We've identified 1 smart contract, `0x4d70C3393C5d9EC325Edf8b3f289cFA9777e64B0`, that has insecure encryption implementation that could allow dumping of all plaintext commands ever sent to the C2. If we can identify additional smart contracts on the blockchain, that share identical bytecode - they could also be malicious and storing C2 commands.

On 13/02/2025, there are 400 addresses hosting this identical smart contract bytecode:   

[![1](/assets/images/block/46.png)](/assets/images/block/46.png){: .full}  

Each of these could potentially be malicious and be abused, although checking manually is tiresome, and most of the contract addresses have no activity. We can leverage [Etherscan.io](https://etherscan.io/apis)'s free API to automate pulling the event logs for each 400 addresses. We can also attempt to manually decrypt using the insecure encryption implementation we identified.

### Decrypting TA comms :)

Currently, we have a list of 394 smart contract addresses that contain identical bytecode. We've seen 1 case where this has been abused. In order to scale up analysis, we can attempt to retrieve the following information from each of these addresses:

* Address of smart contract creator - Use Etherscan API function `getcontractcreation` from module `contract` 
* Timestamped event log - Use Etherscan API function `getLogs` from module `logs`

Whenver using the Etherscan API, we have to specify the relevant chainid for Polygon mainnet - `137`

After getting an event log, we can insepct the values to check whether all data is following the same AES-GCM encryption scheme we observed. We actually observed this same smart contract bytecode used for other malice, rather than just **Aeternum Loader**. Some of these may be plaintext, just hex-encoded, following the AES-GCM scheme we observed, or something else all together. 


**All Contract Creators (Full Addresses)**


| # | Creator Address | Contracts Deployed | Total TXs Sent |
|---|-----------------|-------------------|----------------|
| 1 | 0xcaf2c54e400437da717cf215181b170f65187abf | 32 | 94 |
| 2 | 0x6e3c232c3c61dfce05e677cc351b3d0d677ee49b | 22 | 34 |
| 3 | 0x610676ee857fcab6e6a8631a8867173b4c88350a | 8 | 46 |
| 4 | 0x2a4ff9e51bce71608106f10fce030f092e427ba2 | 4 | 21 |
| 5 | 0x000000000000f734e8782606855a209b421dafd6 | 3 | 6 |
| 6 | 0xbe372a40ea19db6f4641963b4741b1ff6a0de734 | 3 | 3 |
| 7 | 0xbe42e390c0701eff421e6d77ab89aa503831e8ac | 2 | 11 |
| 8 | 0x48acf8b2aaa35762df1ce49c562fa1914d833114 | 1 | 2 |
| 9 | 0xe46de816cf8c5b8c39f0332b1968a5d8cbace6a1 | 1 | 5 |
| 10 | 0x97b00151b02c361b6179de6618dbda43838aedcc | 1 | 1 |
| 11 | 0x460597a2fd0cd963f3c0575ff44f1c14bc59839c | 1 | 1 |
| 12 | 0x7d4f1154be8471e324e7dbd8c16254618042f6df | 1 | 3 |
| 13 | 0x1e34686a32cc2a9719418cb2b26233f61330d693 | 1 | 8 |
| 14 | 0xb0e2a3f37c6abc102678c0677dbe9c36cb79e0b1 | 1 | 1 |




---
 

